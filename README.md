# Тестовые задания
Вопрос №1:
  isEven.py - пример с целочисленным делением.
  isEven_AND.py - решение с бинарным оператором "И".

Разницы по времени выполнения операторов не заметил (прим.: time_Even.py и     time_Even_AND.py). Однако в сети наткнулся на указание, что выполнение с целочисленным делением быстрее. Переведя программы в байт-код получил подтверждение: 308 байт против 312 байт.

Вопрос №2:
  Задача 2 кольцевой буфер.py - Реализован кольцевой буфер FIFO с защитой от перезаписи с использованием триггеров начала и конца очереди. Так как массив элементов буфера не меняет свой размер - нет необходимости в дополнительной памяти. Однако скорость добавления и изьятия элементов в отличии от следующего метода ниже.
  Задача 2 кольцевой буфер_deque.py - Используя структуру deque модуля collections при фиксировании максимального размера можно также реализовать логику кольцевого буффера. Так как добавление и изьятие элементов структуры оптимизированы - операции проходят быстрее. Но deque - это двусвязный список и при увеличении длины буфера будет соответственно увеличиваться требования к памяти. Также доступ к конкретному элементу и операции с ним будут выполняться медленнее, чем в первом случае.

Вопрос №3:
  Реализован алгоритм сортировки слиянием (Merge sort) для массива случайных чисел. В отличии от быстрой сортировки средняя скорость выполнения алгоритма остается постоянной при любых наборах данных. Так как по условию задачи основной критерий - скорость, то Merge sort очевидный выбор. Если на первом месте стояло бы экономное использование памяти, то лучшим решением была бы быстрая сортировка. У сортировки слиянием есть улучшение по скорости - Timsort. Собственно функция sort() в Python вызывает алгоритм Timsort. Но улучшение по скорости будет лишь в том случае, если в исследуемом массиве найдутся уже упорядоченные подмассивы.
